const express = require("express");
const app = express();
const http = require("http");
const server = http.createServer(app);
const {Server} = require("socket.io");
const {Engine, Bodies, Body, World} = require("matter-js");
import { v4 as uuidv4 } from 'uuid';

/*
Have a map structure that maps the "Game-ID" to the two players + physics engine
Better experience only two players to a game.

Game-ID will be generated by 
*/
// Allows for client to connect while orignally @ localhost:3000 or else CORS errors
const io = new Server(server, {
	cors: {
		origin: "*",
		methods: ["GET", "POST"],
	},
});

const PORT = 4000 || process.env.PORT;

const ARENA_SIZE = 1200;
const HEARTBEAT_TIME = 1000 / 60;
const DEFAULT_RADIUS = 50;

let players = new Map();
let playerBodies = new Map();

let playerOptions = {
	friction: 1,
	density: 10,
	restitution: -0.5,
	frictionAir: 0.02,
};

let worldOptions = {
	gravity: {x: 0, y: 0},
};


let allIds = [];
const inactiveIds = new Map();
let gameIDToGame = new Map();

setInterval(() => {
	heartbeat();
}, HEARTBEAT_TIME);

class Player {
	constructor(x, y, r, socketId, name = "", color = {}, gameId) {
		this.x = x;
		this.y = y;
		this.r = r;
		this.vector = {x: 0, y: 0};
		this.socketId= socketId;
		this.name = name;
		this.color = color;
		this.score = Date.now();
		this.gameId = gameId;
	}
}


function removePlayer(id, filterAll) {
	World.remove(world, playerBodies.get(id));
	playerBodies.delete(id);
	players.delete(id);
	inactiveIds.delete(id);

	// Avoids double checking allIds array
	if (filterAll) {
		allIds = allIds.filter((sockId) => sockId != id);
	}
}

function heartbeat() {
	Engine.update(engine, HEARTBEAT_TIME);

	// Filters and updates player positions at the same time
	allIds = allIds.filter((item) => {
		// Remove a player if a no message sent after 10 seconds
		if (inactiveIds.has(item) && Date.now() - inactiveIds.get(item) >= 10000) {
			removePlayer(item, false);
			return false;
		}

		players.get(item).x = playerBodies.get(item).position.x;
		players.get(item).y = playerBodies.get(item).position.y;
		players.get(item).r = playerBodies.get(item).circleRadius;
		players.get(item).vector = playerBodies.get(item).force;

		if (
			players.get(item).x > ARENA_SIZE ||
			players.get(item).x < 0 ||
			players.get(item).y > ARENA_SIZE ||
			players.get(item).y < 0
		) {
			if (playerBodies.get(item).circleRadius <= 25) {
				io.to(item).emit("Death", {msg: "You have died", deathTime: 3000});
				removePlayer(item, false);

				// returning false removes them from allIds.
				return false;
			} else {
				// Makes the player shrink
				Body.scale(playerBodies.get(item), 0.995, 0.995);
			}
		}

		return true;
	});

	// Maps cannot be JSON encoded so it must be converted to an array then encoded
	// Something to do with a map not being serializable?
	let d = {
		map: JSON.stringify(Array.from(players)),
		ids: allIds,
	};

	io.sockets.emit("heartbeat", d);
}

io.on("connection", (socket) => {
	socket.on("disconnect", (sck) => {
		console.log(`Client disconnecting: ${sck}`);

		// Remove player on disconnect
		if (allIds.includes(socket.id)) {
			removePlayer(socket.id, true);
		}
	});

	socket.on("setNameAndColor", (data) => {

		players.get(socket.id).color = data.color;
		players.get(socket.id).name = data.name;
	});

	socket.on("update", (data) => {
		inactiveIds.set(socket.id, Date.now());

		try {
			if (players.has(socket.id)) {

				// Run server simulation from vector data received from client
				Body.applyForce(playerBodies.get(socket.id), {x: 0, y: 0}, data.vector);

				// Redundant because playerBody position doesn't update till engine is stepped.
				// Also messy but idc
				players.set(socket.id, {
					...data,
					score: players.get(socket.id).score,
					name: players.get(socket.id).name,
					color: players.get(socket.id).color,
				});
			}
		} catch (err) {
			console.error(err);
		}
	});

	let x = Math.floor(Math.random() * ARENA_SIZE);
	let y = Math.floor(Math.random() * ARENA_SIZE);

// 	let body = Bodies.circle(x, y, DEFAULT_RADIUS, playerOptions);

	// let engine = Engine.create(worldOptions);
	// let world = engine.world;

	// 	World.add(world, body);

	playerBodies.set(socket.id, body);

	/*
	2 cases to check when a new player joins
	No games / All Games full -> Create a new game and add player to it
	Games and one w/ open spot -> add player to it
	*/

	const iter = gameIDToGame.entries;

	let playerAdded = false;
	let gameId = ""

	for (const [key, value] in iter){
		// Player can join this game
		if(value.length == 1){
			playerAdded = true;
			value.push(new Player(x, y, DEFAULT_RADIUS, socket.id, "", {}, key));
			gameId = key;
			break;	
		}
	}

	if(!playerAdded){
		
		gameId = uuidv4();
		
		const gameObject = {
			game: null,
			players:[],
		}

		gameObject.players.push([new Player(x, y, DEFAULT_RADIUS, socket.id, "", {},gameId)]);

		gameIDToGame.set(gameId, gameObject); 

	}

	allIds.push(socket.id);

	socket.emit("join", {
		...gameIDToGame.get(gameId).players.filter((player) => player.socketId == socket.id),
		ArenaSize: ARENA_SIZE,
		playerOptions,
	});

	console.log(`Player joined: ${socket.id}`);
});

server.listen(PORT, () => {
	console.log(`Listening on port ${PORT}`);
});
