import express from 'express';
const app = express();
import http from 'http';
const server = http.createServer(app);
import { Server } from 'socket.io'
import pkg from 'matter-js';
const { Engine, Bodies, Body, World, Matter } = pkg;
import { v4 as uuidv4 } from 'uuid';

/*
Have a map structure that maps the "Game-ID" to the two players + physics engine
Better experience only two players to a game.

Game-ID will be generated by 
*/
// Allows for client to connect while orignally @ localhost:3000 or else CORS errors
const io = new Server(server, {
    cors: {
        origin: "*",
    },
});

const PORT = 4000 || process.env.PORT;

const ARENA_RADIUS = 1200;
const HEARTBEAT_TIME = 1000 / 60;
const DEFAULT_RADIUS = 50;
const PLAYER_TIMEOUT = 100;
const gameStatus = {
    WAITING: "waiting",
    PLAYING: "playing",
    WON: "won",
    GAME_START: "game_start"
}

const spawnOptions = [[[-1, 0], [1, 0]], [[0, 1], [0, -1]]];

let playerOptions = {
    friction: 1,
    density: 10,
    restitution: -0.5,
    frictionAir: 0.02,
};

let worldOptions = {
    gravity: { x: 0, y: 0 },
};


const idToSocket = new Map();
let gameIDToGame = new Map();
let sockToGame = new Map();
const socketLastSeen = new Map();
const playerBodies = new Map();

setInterval(() => {
    game();
}, HEARTBEAT_TIME);


class Player {
    constructor(x, y, r, socketId, name = "", color = {}, gameId) {
        this.x = x;
        this.y = y;
        this.r = r;
        this.vector = { x: 0, y: 0 };
        this.socketId = socketId;
        this.name = name;
        this.color = color;
        this.score = Date.now();
        this.gameId = gameId;
        this.numWins = 0;
    }
}

function userSetup(socket, name, color) {

    /*
    2 cases to check when a new player joins
    No games / All Games full -> Create a new game and add player to it
    Games and one w/ open spot -> add player to it
    */

    let playerAdded = false;
    let gameId = "";

    idToSocket.set(socket.id, socket);
    socketLastSeen.set(socket.id, Date.now());

    for (const [key, value] of gameIDToGame.entries()) {
        // Player can join this game
        if (value.players.length == 1) {
            gameId = key;
            playerAdded = true;
            let x = (ARENA_RADIUS / 2) * value.spawnLocations[Math.abs(value.spawnChosen - 1)][0];
            let y = (ARENA_RADIUS / 2) * value.spawnLocations[Math.abs(value.spawnChosen - 1)][1];

            const body = Bodies.circle(x, y, DEFAULT_RADIUS, playerOptions);

            World.add(value.engine.world, body);

            const p = new Player(x, y, DEFAULT_RADIUS, socket.id, name, color, key);

            value.players.push(p);


            playerBodies.set(socket.id, body);

            sockToGame.set(socket.id, gameId);

            break;
        }
    }

    if (!playerAdded) {
        gameId = uuidv4();

        let spwn = spawnOptions[Math.round(Math.random())]

        let randLoc = Math.round(Math.random());

        let x = (ARENA_RADIUS / 2) * spwn[randLoc][0];
        let y = (ARENA_RADIUS / 2) * spwn[randLoc][1];

        const body = Bodies.circle(x, y, DEFAULT_RADIUS, playerOptions);
        const engine = Engine.create(worldOptions);

        World.add(engine.world, body);
        playerBodies.set(socket.id, body);
        sockToGame.set(socket.id, gameId);

        let gameObject = {
            engine: engine,
            players: [],
            status: gameStatus.WAITING,
            gameStartTimerId: null,
            spawnLocations: spwn,
            spawnChosen: randLoc
        }

        gameObject.players.push(new Player(x, y, DEFAULT_RADIUS, socket.id, name, color, gameId));
        gameIDToGame.set(gameId, gameObject);

    }


    sendPlayerInitData(gameIDToGame.get(gameId).players.filter((p) => p.socketId === socket.id)[0], ARENA_RADIUS, playerOptions);

}

function sendPlayerInitData(player, playerOptions) {

    idToSocket.get(player.socketId).emit("init_data", {
        player: player,
        ARENA_RADIUS: ARENA_RADIUS,
        playerOptions,
    });

}



function game() {


    /*
    1. Award winners as needed
    2. Delete Games & Players as needed
    3. Send heartbeat to players
    4. If game stalled status != waiting && game.players == 1 
    
    * Now need to handle disconnect events when the status is waiting and game_start
    */

    let winners = heartbeat();

    makeWinners(winners);
    deleteGames(winners);
    deleteSockets();

}


function deleteSockets() {

    for (const [sockId, time] of socketLastSeen.entries()) {
       
        // This is necessary because socket might be added
        // I think this is possible because the client might send a ping
        // Before all objects have been created server side
        if(!sockToGame.has(sockId)) continue;

        const currGameStatus = gameIDToGame.get(sockToGame.get(sockId)).status;

         if (Date.now() - time > PLAYER_TIMEOUT ){
            deletePlayer(sockId);

         }
        // if (Date.now() - time > 5000 && currGameStatus == gameStatus.WAITING) {
        //     deletePlayer(sockId);
        // }

        // if (Date.now() - time > 1000 && currGameStatus == gameStatus.PLAYING) {
        //     deletePlayer(sockId);
        // }

        // if (Date.now() - time > 5000 && currGameStatus == gameStatus.GAME_START) {
        //     deletePlayer(sockId);
        // }

    }


}

function makeWinners(winners) {

    for (const player of winners) {

        const gameId = player.gameId;
        const game = gameIDToGame.get(gameId);

        const loser = game.players.filter((loser) => loser.socketId != player.socketId)[0];

        if (loser != null) {
            idToSocket.get(loser.socketId).emit('game_end', { msg: "loser" });
            idToSocket.get(player.socketId).emit('game_end', { msg: "winner" });
        }

        else {
            idToSocket.get(player.socketId).emit('game_end', { msg: "Opponnent disconnected" });
        }
    }


}

function getMagnitude(x, y) {

    return (Math.sqrt((Math.pow(x, 2) + Math.pow(y, 2))));
}

function deleteGames(winners) {

    for (const winner of winners) {
        const game = gameIDToGame.get(winner.gameId);

        clearInterval(game.gameStartTimerId);

        game.players.forEach((p) => {
            deletePlayer(p.socketId);
        });

        gameIDToGame.delete(winner.gameId);
    }
}


// TYPE: SocketID string
function deletePlayer(socketId) {

    let game = gameIDToGame.get(sockToGame.get(socketId))
    game.players = game.players.filter((player) => player.socketId != socketId);

    try {

        playerBodies.delete(socketId);
        socketLastSeen.delete(socketId);
        idToSocket.get(socketId).disconnect(true);
        idToSocket.delete(socketId);
    }
    catch (err) {
        console.error(`Error: ${err}`);
    }
    console.log(`Removing Player ${socketId}`);
}

function heartbeat() {

    // Iterate through each game object to step the physics engine and
    // send the client updated data
    let winners = [];

    gameIDToGame.forEach((value, key) => {


        const startTime = Date.now() + 3000;
        if (value.players.length == 2 && value.status == gameStatus.WAITING) {
            value.status = gameStatus.GAME_START;
            value.players.forEach((player) => {

                // Get each to start after a 3 second delay at the same time
                idToSocket.get(player.socketId).emit('game_start', { startTime: startTime });
            });


            // I think this is causing issues because players may disconnect during the Game_start phase, but this event still happens
            value.gameStartTimerId = setTimeout(() => {
                value.status = gameStatus.PLAYING;
            }, startTime - Date.now());

        }
        else if (value.players.length == 2 && value.status === gameStatus.PLAYING) {


            // Suspect its because the client feeds NAN in updates 
            Engine.update(value.engine, HEARTBEAT_TIME);

            value.players.forEach((player) => {

                if (getMagnitude(player.x, player.y) > ARENA_RADIUS) {
                    value.status = gameStatus.WON;
                    winners.push(player);
                }

                const { x, y } = playerBodies.get(player.socketId).position;
                player.x = x;
                player.y = y;


            });
        }

      
        value.players.forEach((player) => {
            
            idToSocket.get(player.socketId).emit('heartbeat', value.players);
        });
    });


        return winners;

}

io.on("connection", (socket) => {

    socket.on("update", (data) => {
        try {
            if (socketLastSeen.has(socket.id)) {
                socketLastSeen.set(socket.id, Date.now());
                Body.applyForce(playerBodies.get(socket.id), { x: 0, y: 0 }, data.vector);
            }
        }
        catch (err) {
            console.error(err);
        }


    });

    socket.on("ping", () => {
        socketLastSeen.set(socket.id, Date.now());
    });


    socket.once("join", (data) => {

        userSetup(socket, data.playerName, data.color);
    })



    console.log(`Player joined: ${socket.id}`);
});



server.listen(PORT, () => {
    console.log(`Listening on port ${PORT}`);
});