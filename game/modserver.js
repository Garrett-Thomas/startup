import express from 'express';
const app = express();
import http from 'http';
const server = http.createServer(app);
import { Server } from 'socket.io'
import pkg from 'matter-js';
const { Engine, Bodies, Body, World, Matter } = pkg;
import { v4 as uuidv4 } from 'uuid';
import cors from 'cors';
import fs from 'fs';
import {MongoClient, ServerApiVersion} from 'mongodb';
import leaderboardController from './routes/leaderboard.js';
/*
Have a map structure that maps the "Game-ID" to the two players + physics engine
Better experience only two players to a game.

Game-ID will be generated by 
*/
// Allows for client to connect while orignally @ localhost:3000 or else CORS errors

const io = new Server(server, {
    cors: {
        origin: "*",
    },
});
app.use(cors());

const PORT = 4000 || process.env.PORT;
const ARENA_RADIUS = 2000;
const HEARTBEAT_TIME = 1000 / 60;
const DEFAULT_RADIUS = 50;
const PLAYER_TIMEOUT = 100;
const OBSTACLE_RADIUS = 200;

const AUTH_STRING = fs.readFileSync('.secret/db.txt', 'utf-8').trim();
const client = new MongoClient(AUTH_STRING, {
    serverApi: {
      version: ServerApiVersion.v1,
      strict: true,
      deprecationErrors: true,
    }
  });

await client.connect();
await client.db("startup").command({ping: 1});

const gameStatus = {
    WAITING: "waiting",
    PLAYING: "playing",
    WON: "won",
    GAME_START: "game_start"
}

const spawnOptions = [[[-1, 0], [1, 0]], [[0, 1], [0, -1]]];

const PLAYER_OPTIONS = {
    friction: 0,
    density: 1,
    restitution: 0,
    frictionAir: 0,
    slop: -1
};

const OBSTACLE_OPTIONS = {
    isStatic: true,
    restitution: 0,
    friction: 0,
}

const WORLD_OPTIONS = {
    gravity: { x: 0, y: 0 },
};


const idToSocket = new Map();
let gameIDToGame = new Map();
let sockToGame = new Map();
const socketLastSeen = new Map();
const playerBodies = new Map();

setInterval(() => {
    game();
}, HEARTBEAT_TIME);

class Obstacle {
    constructor(x, y, r) {
        this.x = x;
        this.y = y;
        this.r = r;
    }
}

class Player {
    constructor(x, y, r, socketId, name = "", color = {}, gameId) {
        this.x = x;
        this.y = y;
        this.r = r;
        this.vector = { x: 0, y: 0 };
        this.socketId = socketId;
        this.name = name;
        this.color = color;
        this.score = Date.now();
        this.gameId = gameId;
        this.numWins = 0;
    }
}

function userSetup(socket, name, color) {

    /*
    2 cases to check when a new player joins
    No games / All Games full -> Create a new game and add player to it
    Games and one w/ open spot -> add player to it
    */

    let playerAdded = false;
    let gameId = "";

    idToSocket.set(socket.id, socket);
    socketLastSeen.set(socket.id, Date.now());

    for (const [key, value] of gameIDToGame.entries()) {
        // Player can join this game
        if (value.players.length == 1) {
            gameId = key;
            playerAdded = true;
            let x = (ARENA_RADIUS / 2) * value.spawnLocations[Math.abs(value.spawnChosen - 1)][0];
            let y = (ARENA_RADIUS / 2) * value.spawnLocations[Math.abs(value.spawnChosen - 1)][1];

            const body = Bodies.circle(x, y, DEFAULT_RADIUS, PLAYER_OPTIONS);

            World.add(value.engine.world, body);

            const p = new Player(x, y, DEFAULT_RADIUS, socket.id, name, color, key);

            value.players.push(p);


            playerBodies.set(socket.id, body);

            sockToGame.set(socket.id, gameId);

            break;
        }
    }

    if (!playerAdded) {
        gameId = uuidv4();

        const engine = Engine.create(WORLD_OPTIONS);
        const spawnSet = Math.round(Math.random());
        let spwn = spawnOptions[spawnSet];
        let randLoc = Math.round(Math.random());


        let gameObject = {
            engine: engine,
            players: [],
            obstacles: [],
            status: gameStatus.WAITING,
            gameStartTimerId: null,
            spawnLocations: spwn,
            spawnChosen: randLoc
        }


        let xPlayer = (ARENA_RADIUS / 2) * spwn[randLoc][0];
        let yPlayer = (ARENA_RADIUS / 2) * spwn[randLoc][1];
        const body = Bodies.circle(xPlayer, yPlayer, DEFAULT_RADIUS, PLAYER_OPTIONS);

        gameObject.players.push(new Player(xPlayer, yPlayer, DEFAULT_RADIUS, socket.id, name, color, gameId));
        World.add(engine.world, body);
        playerBodies.set(socket.id, body);
        sockToGame.set(socket.id, gameId);



        for (let i = 0; i < 2; i++) {
            let xOb = (ARENA_RADIUS / 2) * spawnOptions[Math.abs(spawnSet - 1)][i][0];
            let yOb = (ARENA_RADIUS / 2) * spawnOptions[Math.abs(spawnSet - 1)][i][1];
            const obBody = Bodies.circle(xOb, yOb, OBSTACLE_RADIUS, { isStatic: true });
            World.add(engine.world, obBody);
            gameObject.obstacles.push(new Obstacle(xOb, yOb, OBSTACLE_RADIUS));
        }

        gameIDToGame.set(gameId, gameObject);

    }


    sendPlayerInitData(socket.id, gameIDToGame.get(gameId));

}

function sendPlayerInitData(socketId, game) {

    idToSocket.get(socketId).emit("init_data", {
        player: game.players.filter((player) => player.socketId === socketId)[0],
        obstacles: game.obstacles,
        ARENA_RADIUS: ARENA_RADIUS,
        PLAYER_OPTIONS,
        OBSTACLE_OPTIONS,
        WORLD_OPTIONS,
    });

}



function game() {


    /*
    1. Award winners as needed
    2. Delete Games & Players as needed
    3. Send heartbeat to players
    4. If game stalled status != waiting && game.players == 1 
    
    * Now need to handle disconnect events when the status is waiting and game_start
    */

    let winners = heartbeat();

    makeWinners(winners);
    deleteGames(winners);
    deleteSockets();

}


function deleteSockets() {


    // Although I'm iterating over stuff I'm deleting there doesn't seem to be an issue
    for (const [sockId, time] of socketLastSeen.entries()) {

        // This is necessary because socket might be added
        // I think this is possible because the client might send a ping
        // Before all objects have been created server side
        if (!sockToGame.has(sockId)) continue;

        const currGame = gameIDToGame.get(sockToGame.get(sockId));
        const currGameStatus = currGame.status;

        if (Date.now() - time > PLAYER_TIMEOUT && currGameStatus == gameStatus.WAITING) {
            // There might be an issue with this call happening at the same time
            // that a new client is looking for a game
            deleteGames(gameIDToGame.get(sockToGame.get(sockId)).players);

        }

        // We have 2 players guranteed connected
        else if (Date.now() - time > PLAYER_TIMEOUT && (currGameStatus == gameStatus.GAME_START || currGameStatus == gameStatus.PLAYING)) {
            const activePlayer = gameIDToGame.get(sockToGame.get(sockId)).players.filter((player) => sockId != player.socketId)[0];
            idToSocket.get(activePlayer.socketId).emit('game_start disconnect', { msg: "Opponent disconnected" });

            deleteGames(gameIDToGame.get(activePlayer.gameId).players.filter((player) => player.socketId == sockId));

        }


    }

}

function makeWinners(winners) {

    for (const player of winners) {

        const gameId = player.gameId;
        const game = gameIDToGame.get(gameId);

        const loser = game.players.filter((loser) => loser.socketId != player.socketId)[0];

        if (loser != null) {
            idToSocket.get(loser.socketId).emit('game_end', { msg: "loser" });
            idToSocket.get(player.socketId).emit('game_end', { msg: "winner" });
        }

        else {
            idToSocket.get(player.socketId).emit('game_end', { msg: "Opponnent disconnected" });
        }
    }


}
function getMagnitude(x, y){
    return Math.sqrt(Math.pow(x, 2) + Math.pow(y, 2));
}

function deleteGames(winners) {

    for (const winner of winners) {
        const game = gameIDToGame.get(winner.gameId);

        if (game.gameStartTimerId != null) {
            clearInterval(game.gameStartTimerId);
        }
        game.players.forEach((p) => {
            deletePlayer(p.socketId);
        });

        gameIDToGame.delete(winner.gameId);
    }
}


// TYPE: SocketID string
function deletePlayer(socketId) {

    let game = gameIDToGame.get(sockToGame.get(socketId))
    game.players = game.players.filter((player) => player.socketId != socketId);

    try {

        playerBodies.delete(socketId);
        socketLastSeen.delete(socketId);
        idToSocket.get(socketId).disconnect(true);
        idToSocket.delete(socketId);
    }
    catch (err) {

        console.error(`Error deleting player: ${err}`);
    }
    console.log(`Removing Player ${socketId}`);
}

function heartbeat() {

    // Iterate through each game object to step the physics engine and
    // send the client updated data
    let winners = [];

    gameIDToGame.forEach((value, key) => {


        if (value.players.length == 2 && value.status == gameStatus.WAITING) {
            const startTime = Date.now() + 3000;
            value.status = gameStatus.GAME_START;
            value.players.forEach((player) => {

                // Get each to start after a 3 second delay at the same time
                idToSocket.get(player.socketId).emit('game_start', { startTime: startTime });
            });


            // I think this is causing issues because players may disconnect during the Game_start phase, but this event still happens
            value.gameStartTimerId = setTimeout(() => {
                value.status = gameStatus.PLAYING;
            }, startTime - Date.now());

        }
        else if (value.players.length == 2 && value.status === gameStatus.PLAYING) {


            Engine.update(value.engine, HEARTBEAT_TIME);
            value.players.forEach((player) => {

                // if (getMagnitude(player.x, player.y) > ARENA_RADIUS) {
                //     value.status = gameStatus.WON;
                //     winners.push(player);
                // }

                const { x, y } = playerBodies.get(player.socketId).position;
                player.x = x;
                player.y = y;


            });
        }


        value.players.forEach((player) => {

            idToSocket.get(player.socketId).emit('heartbeat', {players: value.players, timing: value.engine.timing});
        });
    });


    return winners;

}

io.on("connection", (socket) => {

    socket.on("update", (data) => {
        try {
            if (socketLastSeen.has(socket.id)) {
                socketLastSeen.set(socket.id, Date.now());
                Body.applyForce(playerBodies.get(socket.id), { x: 0, y: 0 }, data.vector);
            }
        }
        catch (err) {
            console.error(err);
        }


    });

    socket.on("ping", () => {
        socketLastSeen.set(socket.id, Date.now());
    });


    socket.once("join", (data) => {
        userSetup(socket, data.playerName, data.color);
    })



    console.log(`Player joined: ${socket.id}`);
});
function dbMiddle(req, res, next){
    req.db = client.db('startup');
    next();
}

app.use(dbMiddle);
app.use(leaderboardController);


server.listen(PORT, () => {
    console.log(`Listening on port ${PORT}`);
});