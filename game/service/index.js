import express from 'express';
const app = express();
import http from 'http';
const server = http.createServer(app);
import { Server } from 'socket.io';

import pkg from 'matter-js';
const { Engine, Bodies, Body, World, Vector} = pkg;
import { v4 as uuidv4 } from 'uuid';
import leaderBoardRoute from './leaderboard.js';
import authRoute from './auth.js';

import { addGameWon, addGamePlayed } from './dbUtils.js';

/*
Have a map structure that maps the "Game-ID" to the two players + physics engine
Better experience only two players to a game.

Game-ID will be generated by 
*/
// Allows for client to connect while orignally @ localhost:3000 or else CORS errors

const io = new Server(server, { cors: {
    origin: '*',
  }});

// app.use(cors());


const PORT = 5500;
const ARENA_RADIUS = 2000;
const HEARTBEAT_TIME = 1000 / 60;
const DEFAULT_RADIUS = 100;
const PLAYER_TIMEOUT = 1000;
const OBSTACLE_RADIUS = 200;

// 10 m/s?
const MAX_SPEED = 15;


const gameStatus = {
    WAITING: "waiting",
    PLAYING: "playing",
    WON: "won",
    GAME_START: "game_start"
}

const spawnOptions = [[[-1, 0], [1, 0]], [[0, 1], [0, -1]]];

const startTime = 3000;



const PLAYER_OPTIONS = {
    friction: 0,
    density: 100,
    restitution: 0,
    frictionAir: 0,
    slop: -1
};

const OBSTACLE_OPTIONS = {
    isStatic: true,
    restitution: 0,
    friction: 0,
    slop: -1,
}

const WORLD_OPTIONS = {
    gravity: { x: 0, y: 0 },
};


const idToSocket = new Map();
let gameIDToGame = new Map();
let sockToGame = new Map();
const socketLastSeen = new Map();
const playerBodies = new Map();
const idToToken = new Map();

setInterval(() => {
    game();
}, HEARTBEAT_TIME);

class Obstacle {
    constructor(x, y, r) {
        this.x = x;
        this.y = y;
        this.r = r;
    }
}

class Player {
    constructor(x, y, r, socketId, name = "", color = {}, gameId) {
        this.x = x;
        this.y = y;
        this.r = r;
        this.vector = { x: 0, y: 0 };
        this.socketId = socketId;
        this.name = name;
        this.color = color;
        this.score = Date.now();
        this.gameId = gameId;
        this.numWins = 0;
    }
}

function userSetup(socket, name, color) {

    /*
    2 cases to check when a new player joins
    No games / All Games full -> Create a new game and add player to it
    Games and one w/ open spot -> add player to it
    */

    let playerAdded = false;
    let gameId = "";

    idToSocket.set(socket.id, socket);
    socketLastSeen.set(socket.id, Date.now());

    for (const [key, value] of gameIDToGame.entries()) {
        // Player can join this game
        if (value.players.length == 1) {
            gameId = key;
            playerAdded = true;
            let x = (ARENA_RADIUS / 2) * value.spawnLocations[Math.abs(value.spawnChosen - 1)][0];
            let y = (ARENA_RADIUS / 2) * value.spawnLocations[Math.abs(value.spawnChosen - 1)][1];

            const body = Bodies.circle(x, y, DEFAULT_RADIUS, PLAYER_OPTIONS);

            World.add(value.engine.world, body);

            const p = new Player(x, y, DEFAULT_RADIUS, socket.id, name, color, key);

            value.players.push(p);


            playerBodies.set(socket.id, body);

            sockToGame.set(socket.id, gameId);

            break;
        }
    }

    if (!playerAdded) {
        gameId = uuidv4();

        const engine = Engine.create(WORLD_OPTIONS);
        const spawnSet = Math.round(Math.random());
        let spwn = spawnOptions[spawnSet];
        let randLoc = Math.round(Math.random());


        let gameObject = {
            engine: engine,
            players: [],
            obstacles: [],
            status: gameStatus.WAITING,
            gameStartTimerId: null,
            spawnLocations: spwn,
            spawnChosen: randLoc,
            lastTime: -1
        }


        let xPlayer = (ARENA_RADIUS / 2) * spwn[randLoc][0];
        let yPlayer = (ARENA_RADIUS / 2) * spwn[randLoc][1];
        const body = Bodies.circle(xPlayer, yPlayer, DEFAULT_RADIUS, PLAYER_OPTIONS);

        gameObject.players.push(new Player(xPlayer, yPlayer, DEFAULT_RADIUS, socket.id, name, color, gameId));
        World.add(engine.world, body);
        playerBodies.set(socket.id, body);
        sockToGame.set(socket.id, gameId);



        for (let i = 0; i < 2; i++) {
            let xOb = (ARENA_RADIUS / 2) * spawnOptions[Math.abs(spawnSet - 1)][i][0];
            let yOb = (ARENA_RADIUS / 2) * spawnOptions[Math.abs(spawnSet - 1)][i][1];
            const obBody = Bodies.circle(xOb, yOb, OBSTACLE_RADIUS, { isStatic: true });
            World.add(engine.world, obBody);
            gameObject.obstacles.push(new Obstacle(xOb, yOb, OBSTACLE_RADIUS));
        }

        gameIDToGame.set(gameId, gameObject);

    }


    sendPlayerInitData(socket.id, gameIDToGame.get(gameId));

}

function sendPlayerInitData(socketId, game) {

    idToSocket.get(socketId).emit("init_data", {
        player: game.players.filter((player) => player.socketId === socketId)[0],
        obstacles: game.obstacles,
        ARENA_RADIUS: ARENA_RADIUS,
        PLAYER_OPTIONS,
        OBSTACLE_OPTIONS,
        WORLD_OPTIONS,
    });

}



function game() {


    /*
    1. Award winners as needed
    2. Delete Games & Players as needed
    3. Send heartbeat to players
    4. If game stalled status != waiting && game.players == 1 
    
    * Now need to handle disconnect events when the status is waiting and game_start
    */

    let winners = heartbeat();

    makeLosers(winners);
    deleteGames(winners);
    deleteSockets();

}


function deleteSockets() {


    // Although I'm iterating over stuff I'm deleting there doesn't seem to be an issue
    for (const [sockId, time] of socketLastSeen.entries()) {

        if (!sockToGame.has(sockId)) continue;

        const currGame = gameIDToGame.get(sockToGame.get(sockId));
        const currGameStatus = currGame.status;

        if (Date.now() - time > PLAYER_TIMEOUT && currGameStatus == gameStatus.WAITING) {
            // There might be an issue with this call happening at the same time
            // that a new client is looking for a game
            deleteGames(gameIDToGame.get(sockToGame.get(sockId)).players);

        }

        // We have 2 players guranteed connected
        else if (Date.now() - time > PLAYER_TIMEOUT && (currGameStatus == gameStatus.GAME_START || currGameStatus == gameStatus.PLAYING)) {
            const activePlayer = gameIDToGame.get(sockToGame.get(sockId)).players.filter((player) => sockId != player.socketId)[0];
            idToSocket.get(activePlayer.socketId).emit('game_start disconnect', { msg: "Opponent disconnected" });

            deleteGames(gameIDToGame.get(activePlayer.gameId).players.filter((player) => player.socketId == sockId));

        }


    }

}

function makeLosers(winners) {

    for (const loser of winners) {

        const gameId = loser.gameId;
        const game = gameIDToGame.get(gameId);

        const winner = game.players.filter((player) => loser.socketId != player.socketId)[0];
        const winnerToken = idToToken.get(winner.socketId);
        const loserToken = idToToken.get(loser.socketId);
        if (loser != null) {
            idToSocket.get(loser.socketId).emit('game_end', { msg: "You Lost!" });
            idToSocket.get(winner.socketId).emit('game_end', { msg: "You Won!" });

            if (loserToken) {
                addGamePlayed(loserToken);
            }
        }

        else {
            idToSocket.get(winner.socketId).emit('game_end', { msg: "Opponnent disconnected" });
        }

        if (winnerToken) {

            console.log(winnerToken);
            addGameWon(winnerToken);
            addGamePlayed(winnerToken);

        }

    }


}
function getMagnitude(x, y) {
    return Math.sqrt(Math.pow(x, 2) + Math.pow(y, 2));
}

function deleteGames(winners) {

    for (const winner of winners) {
        const game = gameIDToGame.get(winner.gameId);

        if (game.gameStartTimerId != null) {
            clearInterval(game.gameStartTimerId);
        }
        game.players.forEach((p) => {
            deletePlayer(p.socketId);
        });

        gameIDToGame.delete(winner.gameId);
    }
}


// TYPE: SocketID string
function deletePlayer(socketId) {

    let game = gameIDToGame.get(sockToGame.get(socketId))
    game.players = game.players.filter((player) => player.socketId != socketId);

    try {

        playerBodies.delete(socketId);
        socketLastSeen.delete(socketId);
        idToSocket.get(socketId).disconnect(true);
        idToSocket.delete(socketId);
        idToToken.delete(socketId);
    }
    catch (err) {

        console.error(`Error deleting player: ${err}`);
    }
    console.log(`Removing Player ${socketId}`);
}

function heartbeat() {

    // Iterate through each game object to step the physics engine and
    // send the client updated data
    let losers = [];

    gameIDToGame.forEach((value, key) => {


        if (value.players.length == 2 && value.status == gameStatus.WAITING) {
            value.status = gameStatus.GAME_START;

            let currTime = Date.now();
            value.players.forEach((player) => {

                // Get each to start after a 3 second delay at the same time
                idToSocket.get(player.socketId).emit('game_start', { startTime: startTime + currTime });
            });


            // I think this is causing issues because players may disconnect during the Game_start phase, but this event still happens
            value.gameStartTimerId = setTimeout(() => {
                value.status = gameStatus.PLAYING;
            }, (startTime + currTime) - Date.now());

        }
        else if (value.players.length == 2 && value.status === gameStatus.PLAYING) {

            if(value.lastTime === -1){
                value.lastTime = Date.now();

            Engine.update(value.engine, HEARTBEAT_TIME);
            }
            else{

            Engine.update(value.engine, Date.now() - value.lastTime);
                value.lastTime = Date.now();
            }

            value.players.forEach((player, index) => {

                // if (getMagnitude(player.x, player.y) > ARENA_RADIUS) {
                //     value.status = gameStatus.WON;
                //     losers.push(player);
                // }
                
                const playerBody = playerBodies.get(player.socketId);
                const { x, y } = playerBody.position;
                player.x = x;
                player.y = y;
                if(Vector.magnitude(playerBody.velocity) > MAX_SPEED){
                    playerBody.velocity = Vector.mult(Vector.normalise(playerBody.velocity), MAX_SPEED);
                }

            });
        }


        value.players.forEach((player) => {

            idToSocket.get(player.socketId).emit('heartbeat', { players: value.players, time: Date.now() });
        });
    });


    return losers;

}

io.on("connection", (socket) => {

    socket.on("update", (data) => {
        try {
            if (socketLastSeen.has(socket.id)) {
                socketLastSeen.set(socket.id, Date.now());
                const player = playerBodies.get(socket.id);
                

                Body.applyForce(player, { x: 0, y: 0 }, data.vector);

            }
        }
        catch (err) {
            console.error(err);
        }


    });

    socket.on("ping", () => {
        socketLastSeen.set(socket.id, Date.now());
    });


    socket.once("join", (data) => {


        if (data.token) {

            // Easiest to make a new data structure to store this
            idToToken.set(socket.id, data.token);
        }
        userSetup(socket, data.playerName, data.color);
    })



    console.log(`Player joined: ${socket.id}`);
});


app.use(express.json());

app.use('/api/leaderboard', leaderBoardRoute);


app.use('/api/', authRoute);

app.use(express.static('public'));

server.listen(PORT, () => {
    console.log(`Listening on port ${PORT}`);
});